# Learn Kubernetes in a Month of Lunches: Stoneman, Elton

## 2. 파드와 디플로이먼트로 컨테이너 실행하기

### pod

* pod : 쿠버네티스에서 컴퓨팅의 최소 단위.
* pod 아래에 컨테이너를 가지고, pod가 단일 ip를 가진다. 
  * pod 안에 center/game/io 인스턴스 같이 띄우면 localhost로 통신 가능
  * 서버가 죽어서 새 컨테이너가 실행되어도 pod의 ip는 변하지 않는다.

### 컨트롤러 객체

다른 객체를 다시 추상화한 것. 다른 리소스를 관리하는 k8s 리소스.
여러가지 컨트롤러 객체가 있으나 파드를 주로 관리하는 컨트롤러 객체는 '디플로이먼트'

### deployment

디플로이먼트만 만들면 파드가 자동으로 생성된다.
자신이 관리할 파드엔 label을 달아 식별한다. app=name
레이블로 리소스간 관계를 파악하는 것은 k8s에서 자주 쓰이는 패턴이다.

### application manifest

json, yaml 포맷이 가능하나 가독성, 주석사용 등 측면에서 yaml을 많이 사용한다.
pod와 deployment를 정의하는 yaml 파일 예제가 있다. 

## 3. 네트워크를 통해 서비스에 파드 연결하기

ip 주소는 파드를 대체할 때 주소가 변경된다는 문제가 있다. 쿠버네티스는 서비스(service)에 
어드레스 디스커버리 기능을 제공하여 이 문제를 해결했다. 

인터넷에서는 IP 주소에 기억하기 쉬운 이름을 붙이는 도메인 네임을 도입하여 이 문제를 해결했었고,
쿠버네티스에서도 같은 해결책을 도입했다. 

서비스의 유형 중 가장 기본이 되는 것을 클러스터IP(clusterIP)라고 한다. 클러스터IP는 클러스터
전체에서 통용되는 IP 주소를 생성하는데, 이 IP 주소는 파드가 어느 노드에 있더라도 접근이 가능하다. 
하지만 이 IP 주소는 클러스터 내에서만 유효하다. 

로드밸런서 : 트래픽을 받은 노드가 아닌 노드에서 실행되는 파드에도 트래픽을 전달할 수 있다. 
노드포트(nodePort) : 클러스터를 구성하는 모든 노드가 이 서비스에 지정된 포트를 주시하며
  들어온 트래픽을 대상 파드의 대상 포트로 전달한다. (실제 사용성은 낮다.)

익스터널 네임 (external name) : 어떤 도메인 네임에 대한 별명이라고 생각하면 쉽다.
  익스터널네임 서비스는 애플리케이션이 사용하는 주소가 가리키는 대상을 치환해 줄 뿐 요청의 내용 자체를
  바꾸지는 않는다. 데이터베이스처럼 TCP 프로토콜이면 문제없지만, HTTP 요청의 헤더에는 대상 호스트명이
  들어가기 때문에 요청이 실패한다. 
헤드리스 서비스(headless service) : 클러스터IP의 형태로 정의하지만 selector가 없다. 자신이 제공해야할 ip목록이 담긴 엔드포인트와 함께 배포된다.
  
### 3.5 쿠버네티스 서비스의 해소 과정

쿠버네티스 NDS 서버는 엔드포인트 IP 주소가 아닌 클러스터의 IP 주소를 반환한다. 엔드포인트가 가리키는 IP 주소는 계속 변화하기 때문이다. 
모든 쿠버네티스 리소스는 네임스페이스 안에 존재한다. 네임스페이스는 쿠버네티스 클러스터를 논리적 파티션으로 나누는 역할을 한다.
서비스 이름은 로컬 도메인 네임으로 사용되는데, 로컬 도메인 네임은 네임스페이스를 포함하는 완전한 도메인 네임의 별명이다.
네임스페이스는 클러스터를 분할하여 보안을 해치지 않고도 클러스터 활용도를 높일 수 있는 강력한 수단이다. 

## 4. 컨피그맵과 비밀값으로 애플리케이션 설정하기
  
k8s에서 컨테이너에 설정을 전달하는 방법은 컨피그맵(configMap)과 시크릿(secret)이 있다.
환경변수는 pod를 정의할 때 env: 필드를 사용하여 설정할 수 있다. 간단한 값을 설정할 때 사용한다.

컨피그맵 데이터 형태는 한 개 이상의 키-값 쌍, 텍스트, 바이너리 파일까지 다양하다. 
키-값 쌍을 저장했다면 파드에서 이를 환경 변수 형태로 주입할 수 있고, 텍스트를 저장했다면 json, xml, yaml, toml, ini등
설정파일을 파드에 전달할 수 있다.
env 항목에서 정의된 값이 envFrom에서 정의된 값보다 우선순위가 높다. 

kubectl의 describe 명령은 출력이 길에 책에서 많이 사용되지 않았으나 자주 사용해 볼 것을 권장. 유용한 정보를 많이 제공한다.

configMap으로 json 파일을 주입하는 첫 번째 예시: 지정된 경로(/config)를 볼륨으로 설정하면서 cm에 연동. cm에는 json 파일의 정의를 담고 있어 컨테이너 내부에 실제 파일형태로 주입. 

- 어플리케이션이 appsettings.json을 먼저 읽고 /config/config.json을 따로 병합하는 동작을 담당했다. 

파드가 동작 중인 상황에서 컨피그맵을 업데이트: 쿠버네티스는 수정된 파일을 컨테이너에 전달하지만, 이후 과정은 애플리케이션이 담당해야 한다(reloading support).

구성이 망가져 제대로 동작하지 않는 volumeMounts 정의를 반영. 새로운 파드는 3번의 시도 후 재시도를 멈추고, 이전 파드가 계속 실행.

### 4.4 비밀값을 이용하여 민감한 정보가 담긴 설정값 다루기

비밀값의 사용법은 컨피그맵과 크게 다르지 않다. 주된 차이점은 노출이 최소화된다. 값을 사용해야 하는 노드에만 전달되고, 디스크에 저장되지 않고 메모리에만 담긴다. 전달 과정과 저장은 모두 암호화되어 있다. 비밀값의 평문은 base64로 인코딩된 상태로 취급된다. 

비밀값 정의를 yaml로 관리할 순 있지만, 양날의 검이기도 하다. 일관적인 애플리케이션 배치가 가능하지만 모든 민감한 데이터가 형상 관리 도구에 노출된다. 

비밀값을 컨테이너가 받아서 사용하는 방법은 2가지가 있다. 

1. 환경 변수로 주입 : envFrom 필드를 사용하여 비밀값을 환경 변수로 주입할 수 있다.
2. 볼륨으로 주입 : 비밀값을 파일로 주입하여 애플리케이션이 파일을 읽어 사용하게 할 수 있다.

### 4.5 쿠버네티스의 애플리케이션 설정 관리

설계 단계에서 염두해야 할 2가지 질문

1. 애플리케이션의 중단 없이 설정 변경에 대응이 필요한가?
2. 민감한 정보를 어떻게 관리할 것인가?

무중단 업데이트가 중요하다면 파드 교체가 반드시 필요해지는 환경 변수는 활용할 수 없다. 컨피그맵이나 비밀값을 업데이트하는 방식이어야 한다. 
컨피그맵이나 비밀값 등 설정 객체를 업데이트하지 않는 대안은 설정 객체의 이름에 버전 명명법을 도입하고 애플리케이션을 업데이트할 때 새로운 설정 객체를 배치한 후 이 새로운 설정 객체를 가리키게 애플리케이션 정의를 수정하는 방식이다. 이 경우 파드 교체 없는 업데이트는 포기해야 하지만 그 대신 설정값 변경의 이력이 남으며, 만일의 경우 이전 설정으로 돌아가는 선택지가 생긴다. 

민감한 정보의 관리. 전담 팀이 있어서 사람이 수동으로 관리하는 방법. 대규모 조직에서 사용할 수 있다. 
다른 대안은 형상 관리 도구에 저장된 yaml 템플릿 파일로 컨피그맵과 비밀값 정의가 생성되는 완전 자동화된 배치. 템플릿 파일에는 민감한 정보가 채워질 빈칸을 두고, 배치 절차 중에 이 빈칸을 애저 키볼트(Azure KeyVault)같은 안전한 곳에 보관된 실제 정보로 채워 yaml 파일을 완성하는 방식이다. 

## 5. 볼륨, 마운트, 클레임을 이용한 데이터 퍼시스턴시

`공디렉터리(EmptyDir)` : 컨테이너 안에서 빈 디렉터리로 초기화. 파드 수준의 스토리지다. 파드와 같은 생애주기를 갖기 때문에 유용할 때가 많다. 공디렉터리 볼륨에 저장된 데이터는 컨테이너가 재시작되더라도 유지된다. 따라서 새로운 컨테이너 역시 자신이 대체한 컨테이너가 기록한 데이터에 바로 접근할 수 있다. 공디렉터리 볼륨은 임시 저장 목적이라면 모든 애플리케이션에서 사용할 수 있다.
파드가 대체되어 새 파드를 만들면 처음 상태인 빈 디렉터리가 된다. 파드가 재시작한 후에도 데이터를 유지하고 싶다면 파드와는 별도의 생애주기를 가진 유형의 볼륨을 마운트해야 한다. 

### 5.2 볼륨과 마운트로 노드에 데이터 저장하기

데이터를 특정 노드에 고정시킬지 말지를 결정해야 한다. 데이터가 고정된다는 것은 대체 파드가 이전 파드와 동일한 노드에만 배치되도록 해야 한다는 의미다. 

가장 간단한 것은 노드의 특정 디렉터리를 가리키는 볼륨이다. 이런 볼륨을 `호스트경로(HostPath)` 볼륨이라고 한다. 호스트경로 볼륨의 가장 큰 문제는 노드가 두 개 이상인 클러스터에서 생긴다. 파드 정의에 항상 같은 노드에서 실행하라는 요구사항을 넣을 수는 있지만, 이렇게 하면 애플리케이션의 자기수복성이 크게 제한된다. 
그 다음 문제는 보안 취약점을 드러낸다는 점이다. 호스트경로 볼륨에 사용할 수 있는 노드상의 디렉터리에는 큰 제한이 없어서, 노트의 파일 시스템 전체에 파드 컨테이너가 접근할 수도 있다. 

### 5.3 전체에서 접근 가능하도록 데이터 저장하기: 영구볼륨과 클레임

분산 스토리지 시스템의 지원을 받는 볼륨 유형 예시 : AKS(Azure Kubernetes Service)에서는 Azure Disk, Azure File, Azure Blob Storage를 지원한다. 
EKS(Amazon Elastic Kubernetes Service)에서는 EBS(Elastic Block Store), EFS(Elastic File System), S3(Simple Storage Service)를 지원한다.
온프레미스 환경에서는 NFS(Network File System)나 Ceph, GlusterFS를 사용할 수 있다. 

파드는 컴퓨팅 계층의 추상이며, 서비스는 네트워크 계층의 추상이라고 설명했다. 스토리지 계층의 추상으로는 `영구볼륨(PersistentVolume, PV)`과 `영구볼륨클레임(PersistentVolumeClaim, PVC)`이 있다. 
